using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Generator;


[Generator]
public class Generator : ISourceGenerator
{

    private string GetBody(ClassMapping from, ClassMapping to)
    {
        List<string> sb = new();

        foreach (var fP in from.Properties)
        {
            var tP = to.Properties.FirstOrDefault(tp => tp == fP);
            if (tP == null) continue;

            sb.Add($"\t\t\t{tP} = from.{fP}");
        }

        return string.Join(",\r\n",sb);
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var receiver = (ClassSyntaxReceiver)context.SyntaxReceiver;

        StringBuilder sb = new();

        // start building the class Mapper
        sb.Append(@"
// <autogenerated file, will be overwritten>

namespace Generator;

public static class Mapper
{
");


        for (int i = 0; i < receiver.ClassMappings.Count; i++)
        {
            var from = receiver.ClassMappings[i];

            for (int j = 0; j < receiver.ClassMappings.Count; j++)
            {
                if (i == j) continue;

                var to = receiver.ClassMappings[j];

                sb.Append($@"
    // map {from.Name} to {to.Name}
    public static {to.Name} Map({from.Name} from) {{
        return new() {{
{GetBody(from, to)}
        }};     
    }}
");
            }

        }
        

        sb.AppendLine(@"
}
");

        context.AddSource("Mapper.g.cs", sb.ToString());
    }


    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ClassSyntaxReceiver());
    }
}


public class ClassSyntaxReceiver : ISyntaxReceiver
{

    public List<ClassMapping> ClassMappings { get; set; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not ClassDeclarationSyntax cds) return; // let only classes thru

        if (!cds.AttributeLists.Any(als => als.Attributes.Any(aS
            => aS.Name.ToString() == "Map"))) return; // let only those with the Map attribute thru

        var properties = cds.Members.Select(mds => mds as PropertyDeclarationSyntax)
            .Where(pds => pds != null)
            .Select(pds => pds.Identifier.Text)
            .ToList();

        ClassMappings.Add(new ClassMapping(cds.Identifier.Text, properties));



    }
}


public record ClassMapping(string Name, List<string> Properties);